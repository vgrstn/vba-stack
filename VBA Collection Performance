# VBA Collection Performance: Tail-Removal Cost

This note documents and reproduces a long-standing performance quirk in `VBA.Collection`:  
**removing the last item** (the “tail”) gets slower as the collection grows, while removing from the **first position** stays fast and size-independent.

## TL;DR

- `Collection` is implemented as a **doubly linked list** with a **hash table** for key lookup.  
- Adding/removing at **position 1** is effectively O(1).  
- Removing the **last item** (by index = `Count`) degrades with size — effectively **O(n)** — because the internal code traverses from the head to reach the tail node.

---

## Why this matters

If you build stacks or queues on top of `Collection` and you treat the “top” as the **last index**, your `Pop`/`Dequeue` cost will grow with `Count`.  
If, instead, you treat the “top” as **index 1**, both `Push` (insert before 1) and `Pop` (remove index 1) stay **constant-time**.

---

## Reproducible Benchmark (VBA)

> The snippets below time four operations:
> 1) **Add item (append)**  
> 2) **Remove last** (index = `Count`) ← **problematic**  
> 3) **Add item at 1** (`before:=1`)  
> 4) **Remove first** (index = `1`)  
>
> Uses a **predeclared `Stopwatch`** class if present; otherwise falls back to `Timer`.  
> (If you don’t have `Stopwatch`, just keep the fallback.)

```vb
' ===== Module: MCollectionBench =====
Option Explicit

Private Type TTimer
    HasStopwatch As Boolean
End Type
Private TT As TTimer

Private Function NowSeconds() As Double
    ' Prefer high-resolution Stopwatch if available (predeclared instance).
    On Error Resume Next
    If Not TT.HasStopwatch Then
        Stopwatch.Start: Stopwatch.Halt   ' probe availability
        TT.HasStopwatch = (Err.Number = 0)
        Err.Clear
    End If
    On Error GoTo 0

    If TT.HasStopwatch Then
        Stopwatch.Start
        NowSeconds = Stopwatch.Elapsed    ' snapshot without stopping
    Else
        NowSeconds = Timer                ' ~10ms resolution; good enough with large loops
    End If
End Function

Private Function ElapsedSince(ByVal t0 As Double) As Double
    If TT.HasStopwatch Then
        ElapsedSince = Stopwatch.Halt     ' seconds since Start
    Else
        ElapsedSince = Timer - t0
        If ElapsedSince < 0 Then ElapsedSince = ElapsedSince + 86400#
    End If
End Function

Public Sub Run_Collection_Benchmarks()
    Dim sizes() As Long: sizes = Array(10, 100, 1000, 10000, 100000)
    Dim rep As Long: rep = 1             ' per-operation repetitions (increase if using Timer)

    Debug.Print "count", "add item", "remove count", "add item @1", "remove 1"

    Dim i As Long, n As Long
    For i = LBound(sizes) To UBound(sizes)
        n = sizes(i)
        BenchOne n, rep
    Next i
End Sub

Private Sub BenchOne(ByVal n As Long, ByVal rep As Long)
    Dim c As New Collection
    Dim i As Long, r As Long
    Dim t0 As Double
    Dim addTail As Double, remTail As Double, addHead As Double, remHead As Double

    ' Preload with n items
    For i = 1 To n: c.Add i: Next

    ' --- add item (append) ---
    For r = 1 To rep
        t0 = NowSeconds()
        c.Add "X"                  ' append at tail
        addTail = addTail + ElapsedSince(t0)
        c.Remove c.Count           ' restore size
    Next r

    ' --- remove last (index = Count) ---
    For r = 1 To rep
        c.Add "X"
        t0 = NowSeconds()
        c.Remove c.Count           ' <-- size-dependent (slow path)
        remTail = remTail + ElapsedSince(t0)
    Next r

    ' --- add item at 1 (before=1) ---
    For r = 1 To rep
        t0 = NowSeconds()
        c.Add "X", before:=1       ' insert at head
        addHead = addHead + ElapsedSince(t0)
        c.Remove 1                 ' restore
    Next r

    ' --- remove first (index=1) ---
    For r = 1 To rep
        c.Add "X", before:=1
        t0 = NowSeconds()
        c.Remove 1                 ' <-- constant-time
        remHead = remHead + ElapsedSince(t0)
    Next r

    ' Average per operation (ms)
    Debug.Print _
        Format$(n, "0"), _
        Format$((addTail / rep) * 1000#, "0.00000"), _
        Format$((remTail / rep) * 1000#, "0.00000"), _
        Format$((addHead / rep) * 1000#, "0.00000"), _
        Format$((remHead / rep) * 1000#, "0.00000")
End Sub

